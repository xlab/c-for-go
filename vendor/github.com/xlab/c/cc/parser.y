// CAUTION: Generated by yy - DO NOT EDIT.

%{
// Copyright 2015 The CC Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Based on [0], 6.10. Substantial portions of expression AST size
// optimizations are from [2], license of which follows.

// ----------------------------------------------------------------------------

// Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This grammar is derived from the C grammar in the 'ansitize'
// program, which carried this notice:
// 
// Copyright (c) 2006 Russ Cox, 
// 	Massachusetts Institute of Technology
// 
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
// 
// The above copyright notice and this permission notice shall
// be included in all copies or substantial portions of the
// Software.
// 
// The software is provided "as is", without warranty of any
// kind, express or implied, including but not limited to the
// warranties of merchantability, fitness for a particular
// purpose and noninfringement.  In no event shall the authors
// or copyright holders be liable for any claim, damages or
// other liability, whether in an action of contract, tort or
// otherwise, arising from, out of or in connection with the
// software or the use or other dealings in the software.

package cc

import (
	"github.com/xlab/c/xc"
	"github.com/cznic/golex/lex"
)
%}

%union {
	Token     xc.Token
	groupPart node
	node      node
	toks      PPTokenList
}

%token	<Token>
	'!'
	'%'
	'&'
	'('
	')'
	'*'
	'+'
	','
	'-'
	'.'
	'/'
	':'
	';'
	'<'
	'='
	'>'
	'?'
	'['
	'\n'
	']'
	'^'
	'{'
	'|'
	'}'
	'~'
	ADDASSIGN                    "+="
	ANDAND                       "&&"
	ANDASSIGN                    "&="
	ARROW                        "->"
	AUTO                         "auto"
	BOOL                         "_Bool"
	BREAK                        "break"
	CASE                         "case"
	CAST
	CHAR                         "char"
	CHARCONST                    "character constant"
	COMPLEX                      "_Complex"
	CONST                        "const"
	CONSTANT_EXPRESSION 1048577  "constant expression prefix"
	CONTINUE                     "continue"
	DDD                          "..."
	DEC                          "--"
	DEFAULT                      "default"
	DIVASSIGN                    "/="
	DO                           "do"
	DOUBLE                       "double"
	ELSE                         "else"
	ENUM                         "enum"
	EQ                           "=="
	EXTERN                       "extern"
	FLOAT                        "float"
	FLOATCONST                   "floating-point constant"
	FOR                          "for"
	GEQ                          ">="
	GOTO                         "goto"
	IDENTIFIER                   "identifier"
	IDENTIFIER_LPAREN            "identifier immediatelly followed by '('"
	IF                           "if"
	INC                          "++"
	INLINE                       "inline"
	INT                          "int"
	INTCONST                     "integer constant"
	LEQ                          "<="
	LONG                         "long"
	LONGCHARCONST                "long character constant"
	LONGSTRINGLITERAL            "long string constant"
	LSH                          "<<"
	LSHASSIGN                    "<<="
	MODASSIGN                    "%="
	MULASSIGN                    "*="
	NEQ                          "!="
	NOELSE
	ORASSIGN                     "|="
	OROR                         "||"
	PPDEFINE                     "#define"
	PPELIF                       "#elif"
	PPELSE                       "#else"
	PPENDIF                      "#endif"
	PPERROR                      "#error"
	PPHASH_NL                    "#"
	PPHEADER_NAME                "header name"
	PPIF                         "#if"
	PPIFDEF                      "#ifdef"
	PPIFNDEF                     "#ifndef"
	PPINCLUDE                    "#include"
	PPLINE                       "#line"
	PPNONDIRECTIVE               "#foo"
	PPNUMBER                     "preprocessing number"
	PPOTHER                      "ppother"
	PPPASTE                      "##"
	PPPRAGMA                     "#pragma"
	PPUNDEF                      "#undef"
	PREPROCESSING_FILE 1048576   "preprocessing file prefix"
	REGISTER                     "register"
	RESTRICT                     "restrict"
	RETURN                       "return"
	RSH                          ">>"
	RSHASSIGN                    ">>="
	SHORT                        "short"
	SIGNED                       "signed"
	SIZEOF                       "sizeof"
	STATIC                       "static"
	STRINGLITERAL                "string literal"
	STRUCT                       "struct"
	SUBASSIGN                    "-="
	SWITCH                       "switch"
	TRANSLATION_UNIT 1048578     "translation unit prefix"
	TYPEDEF                      "typedef"
	TYPEDEFNAME                  "typedefname"
	UNARY
	UNION                        "union"
	UNSIGNED                     "unsigned"
	VOID                         "void"
	VOLATILE                     "volatile"
	WHILE                        "while"
	XORASSIGN                    "^="

%type	<groupPart>
	GroupPart                    "group part"

%type	<node>
	AbstractDeclarator           "abstract declarator"
	AbstractDeclaratorOpt        "optional abstract declarator"
	ArgumentExpressionList       "argument expression list"
	ArgumentExpressionListOpt    "optional argument expression list"
	BlockItem                    "block item"
	BlockItemList                "block item list"
	BlockItemListOpt             "optional block item list"
	CommaOpt
	CompoundStatement            "compound statement"
	ConstantExpression           "constant expression"
	ControlLine                  "control line"
	Declaration                  "declaration"
	DeclarationList              "declaration list"
	DeclarationListOpt           "optional declaration list"
	DeclarationSpecifiers        "declaration specifiers"
	DeclarationSpecifiersOpt     "optional declaration specifiers"
	Declarator                   "declarator"
	DeclaratorOpt                "optional declarator"
	Designation                  "designation"
	DesignationOpt               "optional designation"
	Designator                   "designator"
	DesignatorList               "designator list"
	DirectAbstractDeclarator     "direct abstract declarator"
	DirectAbstractDeclaratorOpt  "optional direct abstract declarator"
	DirectDeclarator             "direct declarator"
	ElifGroup                    "elif group"
	ElifGroupList                "elif group list"
	ElifGroupListOpt             "optional elif group list"
	ElseGroup                    "else group"
	ElseGroupOpt                 "optional else group"
	EndifLine                    "endif line"
	EnumSpecifier                "enum specifier"
	EnumerationConstant          "enumearation constant"
	Enumerator                   "enumerator"
	EnumeratorList               "enumerator list"
	Expression                   "expression"
	ExpressionList               "expression list"
	ExpressionListOpt            "optional expression list"
	ExpressionOpt                "optional expression"
	ExpressionStatement          "expression statement"
	ExternalDeclaration          "external declaration"
	FunctionDefinition           "function definition"
	FunctionSpecifier            "function specifier"
	GroupList                    "group list"
	GroupListOpt                 "optional group list"
	IdentifierList               "identifier list"
	IdentifierListOpt            "optional identifier list"
	IdentifierOpt                "optional identifier"
	IfGroup                      "if group"
	IfSection                    "if section"
	InitDeclarator               "init declarator"
	InitDeclaratorList           "init declarator list"
	InitDeclaratorListOpt        "optional init declarator list"
	Initializer                  "initializer"
	InitializerList              "initializer list"
	IterationStatement           "iteration statement"
	JumpStatement                "jump statement"
	LabeledStatement             "labeled statement"
	PPTokens
	ParameterDeclaration         "parameter declaration"
	ParameterList                "parameter list"
	ParameterTypeList            "parameter type list"
	ParameterTypeListOpt         "optional parameter type list"
	Pointer                      "pointer"
	PointerOpt                   "optional pointer"
	PreprocessingFile            "preprocessing file"
	SelectionStatement           "selection statement"
	SpecifierQualifierList       "specifier qualifier list"
	SpecifierQualifierListOpt    "optional specifier qualifier list"
	Start
	Statement                    "statement"
	StorageClassSpecifier        "storage class specifier"
	StructDeclaration            "struct declaration"
	StructDeclarationList        "struct declaration list"
	StructDeclarator             "struct declarator"
	StructDeclaratorList         "struct declarator list"
	StructOrUnion                "struct-or-union"
	StructOrUnionSpecifier       "struct-or-union specifier"
	TranslationUnit              "translation unit"
	TypeName                     "type name"
	TypeQualifier                "type qualifier"
	TypeQualifierList            "type qualifier list"
	TypeQualifierListOpt         "optional type qualifier list"
	TypeSpecifier                "type specifier"

%type	<toks>
	PPTokenList                  "token list"
	PPTokenListOpt               "optional token list"
	ReplacementList              "replacement list"
	TextLine                     "text line"

%precedence	NOELSE
%precedence	ELSE
%right	'=' ADDASSIGN ANDASSIGN DIVASSIGN LSHASSIGN MODASSIGN MULASSIGN ORASSIGN RSHASSIGN SUBASSIGN XORASSIGN
%left	':' '?'
%left	OROR
%left	ANDAND
%left	'|'
%left	'^'
%left	'&'
%left	EQ NEQ
%left	'<' '>' GEQ LEQ
%left	LSH RSH
%left	'+' '-'
%left	'%' '*' '/'
%precedence	CAST
%left	'!' '~' SIZEOF UNARY
%right	'(' '.' '[' ARROW DEC INC

%start Start

%%

Start:
	PREPROCESSING_FILE PreprocessingFile
	{
		lx := yylex.(*lexer)
		lx.preprocessingFile = $2.(*PreprocessingFile)
	}
|	CONSTANT_EXPRESSION ConstantExpression
	{
		lx := yylex.(*lexer)
		lx.constantExpression = $2.(*ConstantExpression)
	}
|	TRANSLATION_UNIT TranslationUnit
	{
		lx := yylex.(*lexer)
		if lx.report.Errors(false) == nil && lx.scope.kind != ScopeFile {
			panic("internal error")
		}

		lx.translationUnit = $2.(*TranslationUnit).reverse()
		lx.translationUnit.Declarations = lx.scope
	}

EnumerationConstant:
	IDENTIFIER
	{
		$$ = &EnumerationConstant{
			Token:  $1,
		}
	}

ArgumentExpressionList:
	Expression
	{
		$$ = &ArgumentExpressionList{
			Expression:  $1.(*Expression),
		}
	}
|	ArgumentExpressionList ',' Expression
	{
		$$ = &ArgumentExpressionList{
			Case:                    1,
			ArgumentExpressionList:  $1.(*ArgumentExpressionList),
			Token:                   $2,
			Expression:              $3.(*Expression),
		}
	}

ArgumentExpressionListOpt:
	/* empty */
	{
		$$ = (*ArgumentExpressionListOpt)(nil)
		}
|	ArgumentExpressionList
	{
		$$ = &ArgumentExpressionListOpt{
			ArgumentExpressionList:  $1.(*ArgumentExpressionList).reverse(),
		}
	}

Expression:
	IDENTIFIER
	{
		lx := yylex.(*lexer)
		lhs := &Expression{
			Token:  $1,
		}
		$$ = lhs
		lhs.scope = lx.scope
	}
|	CHARCONST
	{
		$$ = &Expression{
			Case:   1,
			Token:  $1,
		}
	}
|	FLOATCONST
	{
		$$ = &Expression{
			Case:   2,
			Token:  $1,
		}
	}
|	INTCONST
	{
		$$ = &Expression{
			Case:   3,
			Token:  $1,
		}
	}
|	LONGCHARCONST
	{
		$$ = &Expression{
			Case:   4,
			Token:  $1,
		}
	}
|	LONGSTRINGLITERAL
	{
		$$ = &Expression{
			Case:   5,
			Token:  $1,
		}
	}
|	STRINGLITERAL
	{
		$$ = &Expression{
			Case:   6,
			Token:  $1,
		}
	}
|	'(' ExpressionList ')'
	{
		$$ = &Expression{
			Case:            7,
			Token:           $1,
			ExpressionList:  $2.(*ExpressionList).reverse(),
			Token2:          $3,
		}
	}
|	Expression '[' ExpressionList ']'
	{
		$$ = &Expression{
			Case:            8,
			Expression:      $1.(*Expression),
			Token:           $2,
			ExpressionList:  $3.(*ExpressionList).reverse(),
			Token2:          $4,
		}
	}
|	Expression '(' ArgumentExpressionListOpt ')'
	{
		lx := yylex.(*lexer)
		lhs := &Expression{
			Case:                       9,
			Expression:                 $1.(*Expression),
			Token:                      $2,
			ArgumentExpressionListOpt:  $3.(*ArgumentExpressionListOpt),
			Token2:                     $4,
		}
		$$ = lhs
		o := lhs.ArgumentExpressionListOpt
		if o == nil {
			break
		}

		m := lx.model
		lhs.Expression.eval(m)
		s := m.adjustFnArgs
		m.adjustFnArgs = true
		for l := o.ArgumentExpressionList; l != nil; l = l.ArgumentExpressionList {
			l.Expression.eval(m)
		}
		m.adjustFnArgs = s
	}
|	Expression '.' IDENTIFIER
	{
		$$ = &Expression{
			Case:        10,
			Expression:  $1.(*Expression),
			Token:       $2,
			Token2:      $3,
		}
	}
|	Expression "->" IDENTIFIER
	{
		$$ = &Expression{
			Case:        11,
			Expression:  $1.(*Expression),
			Token:       $2,
			Token2:      $3,
		}
	}
|	Expression "++"
	{
		$$ = &Expression{
			Case:        12,
			Expression:  $1.(*Expression),
			Token:       $2,
		}
	}
|	Expression "--"
	{
		$$ = &Expression{
			Case:        13,
			Expression:  $1.(*Expression),
			Token:       $2,
		}
	}
|	'(' TypeName ')' '{' InitializerList CommaOpt '}'
	{
		$$ = &Expression{
			Case:             14,
			Token:            $1,
			TypeName:         $2.(*TypeName),
			Token2:           $3,
			Token3:           $4,
			InitializerList:  $5.(*InitializerList).reverse(),
			CommaOpt:         $6.(*CommaOpt),
			Token4:           $7,
		}
	}
|	"++" Expression
	{
		$$ = &Expression{
			Case:        15,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	"--" Expression
	{
		$$ = &Expression{
			Case:        16,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	'&' Expression %prec UNARY
	{
		$$ = &Expression{
			Case:        17,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	'*' Expression %prec UNARY
	{
		$$ = &Expression{
			Case:        18,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	'+' Expression %prec UNARY
	{
		$$ = &Expression{
			Case:        19,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	'-' Expression %prec UNARY
	{
		$$ = &Expression{
			Case:        20,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	'~' Expression
	{
		$$ = &Expression{
			Case:        21,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	'!' Expression
	{
		$$ = &Expression{
			Case:        22,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	"sizeof" Expression
	{
		$$ = &Expression{
			Case:        23,
			Token:       $1,
			Expression:  $2.(*Expression),
		}
	}
|	"sizeof" '(' TypeName ')' %prec SIZEOF
	{
		$$ = &Expression{
			Case:      24,
			Token:     $1,
			Token2:    $2,
			TypeName:  $3.(*TypeName),
			Token3:    $4,
		}
	}
|	'(' TypeName ')' Expression %prec CAST
	{
		$$ = &Expression{
			Case:        25,
			Token:       $1,
			TypeName:    $2.(*TypeName),
			Token2:      $3,
			Expression:  $4.(*Expression),
		}
	}
|	Expression '*' Expression
	{
		$$ = &Expression{
			Case:         26,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '/' Expression
	{
		$$ = &Expression{
			Case:         27,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '%' Expression
	{
		$$ = &Expression{
			Case:         28,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '+' Expression
	{
		$$ = &Expression{
			Case:         29,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '-' Expression
	{
		$$ = &Expression{
			Case:         30,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "<<" Expression
	{
		$$ = &Expression{
			Case:         31,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression ">>" Expression
	{
		$$ = &Expression{
			Case:         32,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '<' Expression
	{
		$$ = &Expression{
			Case:         33,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '>' Expression
	{
		$$ = &Expression{
			Case:         34,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "<=" Expression
	{
		$$ = &Expression{
			Case:         35,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression ">=" Expression
	{
		$$ = &Expression{
			Case:         36,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "==" Expression
	{
		$$ = &Expression{
			Case:         37,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "!=" Expression
	{
		$$ = &Expression{
			Case:         38,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '&' Expression
	{
		$$ = &Expression{
			Case:         39,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '^' Expression
	{
		$$ = &Expression{
			Case:         40,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '|' Expression
	{
		$$ = &Expression{
			Case:         41,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "&&" Expression
	{
		$$ = &Expression{
			Case:         42,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "||" Expression
	{
		$$ = &Expression{
			Case:         43,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression '?' ExpressionList ':' Expression
	{
		$$ = &Expression{
			Case:            44,
			Expression:      $1.(*Expression),
			Token:           $2,
			ExpressionList:  $3.(*ExpressionList).reverse(),
			Token2:          $4,
			Expression2:     $5.(*Expression),
		}
	}
|	Expression '=' Expression
	{
		$$ = &Expression{
			Case:         45,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "*=" Expression
	{
		$$ = &Expression{
			Case:         46,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "/=" Expression
	{
		$$ = &Expression{
			Case:         47,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "%=" Expression
	{
		$$ = &Expression{
			Case:         48,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "+=" Expression
	{
		$$ = &Expression{
			Case:         49,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "-=" Expression
	{
		$$ = &Expression{
			Case:         50,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "<<=" Expression
	{
		$$ = &Expression{
			Case:         51,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression ">>=" Expression
	{
		$$ = &Expression{
			Case:         52,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "&=" Expression
	{
		$$ = &Expression{
			Case:         53,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "^=" Expression
	{
		$$ = &Expression{
			Case:         54,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}
|	Expression "|=" Expression
	{
		$$ = &Expression{
			Case:         55,
			Expression:   $1.(*Expression),
			Token:        $2,
			Expression2:  $3.(*Expression),
		}
	}

ExpressionOpt:
	/* empty */
	{
		$$ = (*ExpressionOpt)(nil)
		}
|	Expression
	{
		lx := yylex.(*lexer)
		lhs := &ExpressionOpt{
			Expression:  $1.(*Expression),
		}
		$$ = lhs
		lhs.Expression.eval(lx.model)
	}

ExpressionList:
	Expression
	{
		$$ = &ExpressionList{
			Expression:  $1.(*Expression),
		}
	}
|	ExpressionList ',' Expression
	{
		$$ = &ExpressionList{
			Case:            1,
			ExpressionList:  $1.(*ExpressionList),
			Token:           $2,
			Expression:      $3.(*Expression),
		}
	}

ExpressionListOpt:
	/* empty */
	{
		$$ = (*ExpressionListOpt)(nil)
		}
|	ExpressionList
	{
		lx := yylex.(*lexer)
		lhs := &ExpressionListOpt{
			ExpressionList:  $1.(*ExpressionList).reverse(),
		}
		$$ = lhs
		lhs.ExpressionList.eval(lx.model)
	}

ConstantExpression:
	Expression
	{
		lx := yylex.(*lexer)
		lhs := &ConstantExpression{
			Expression:  $1.(*Expression),
		}
		$$ = lhs
		lhs.Value, lhs.Type = lhs.Expression.eval(lx.model)
		if lhs.Value == nil {
			lx.report.Err(lhs.Pos(), "not a constant expression")
		}
	}

Declaration:
	DeclarationSpecifiers InitDeclaratorListOpt ';'
	{
		lx := yylex.(*lexer)
		lhs := &Declaration{
			DeclarationSpecifiers:  $1.(*DeclarationSpecifiers),
			InitDeclaratorListOpt:  $2.(*InitDeclaratorListOpt),
			Token:                  $3,
		}
		$$ = lhs
		o := lhs.InitDeclaratorListOpt
		if o != nil {
			break
		}

		s := lhs.DeclarationSpecifiers
		d := &Declarator{specifier: s}
		dd := &DirectDeclarator{
			Token: xc.Token{Char: lex.NewChar(lhs.Pos(), 0)},
			declarator: d,
			idScope: lx.scope,
			specifier: s,
		}
		d.DirectDeclarator = dd
		d.setFull(lx)
		lhs.declarator = d
	}

DeclarationSpecifiers:
	StorageClassSpecifier DeclarationSpecifiersOpt
	{
		lx := yylex.(*lexer)
		lhs := &DeclarationSpecifiers{
			StorageClassSpecifier:     $1.(*StorageClassSpecifier),
			DeclarationSpecifiersOpt:  $2.(*DeclarationSpecifiersOpt),
		}
		$$ = lhs
		lx.scope.specifier = lhs
		a := lhs.StorageClassSpecifier
		b := lhs.DeclarationSpecifiersOpt
		if b == nil {
			lhs.attr = a.attr
			break
		}

		if a.attr&b.attr != 0 {
			lx.report.Err(a.Pos(), "invalid storage class specifier")
			break
		}

		lhs.attr = a.attr|b.attr
		lhs.typeSpecifier = b.typeSpecifier
		if lhs.StorageClassSpecifier.Case != 0 /* "typedef" */ && lhs.IsTypedef() {
			lx.report.Err(a.Pos(), "invalid storage class specifier")
		}
	}
|	TypeSpecifier DeclarationSpecifiersOpt
	{
		lx := yylex.(*lexer)
		lhs := &DeclarationSpecifiers{
			Case:                      1,
			TypeSpecifier:             $1.(*TypeSpecifier),
			DeclarationSpecifiersOpt:  $2.(*DeclarationSpecifiersOpt),
		}
		$$ = lhs
		lx.scope.specifier = lhs
		a := lhs.TypeSpecifier
		b := lhs.DeclarationSpecifiersOpt
		if b == nil {
			lhs.typeSpecifier = a.typeSpecifier
			break
		}

		lhs.attr = b.attr
		ts := tsEncode(append(tsDecode(a.typeSpecifier), tsDecode(b.typeSpecifier)...)...)
		if _, ok := tsValid[ts]; !ok {
			ts = tsEncode(tsInt)
			lx.report.Err(a.Pos(), "invalid type specifier")
		}
		lhs.typeSpecifier = ts
	}
|	TypeQualifier DeclarationSpecifiersOpt
	{
		lx := yylex.(*lexer)
		lhs := &DeclarationSpecifiers{
			Case:                      2,
			TypeQualifier:             $1.(*TypeQualifier),
			DeclarationSpecifiersOpt:  $2.(*DeclarationSpecifiersOpt),
		}
		$$ = lhs
		lx.scope.specifier = lhs
		a := lhs.TypeQualifier
		b := lhs.DeclarationSpecifiersOpt
		if b == nil {
			lhs.attr = a.attr
			break
		}
	
		if a.attr&b.attr != 0 {
			lx.report.Err(a.Pos(), "invalid type qualifier")
			break
		}

		lhs.attr = a.attr|b.attr
		lhs.typeSpecifier = b.typeSpecifier
		if lhs.IsTypedef() {
			lx.report.Err(a.Pos(), "invalid type qualifier")
		}
	}
|	FunctionSpecifier DeclarationSpecifiersOpt
	{
		lx := yylex.(*lexer)
		lhs := &DeclarationSpecifiers{
			Case:                      3,
			FunctionSpecifier:         $1.(*FunctionSpecifier),
			DeclarationSpecifiersOpt:  $2.(*DeclarationSpecifiersOpt),
		}
		$$ = lhs
		lx.scope.specifier = lhs
		a := lhs.FunctionSpecifier
		b := lhs.DeclarationSpecifiersOpt
		if b == nil {
			lhs.attr = a.attr
			break
		}
	
		if a.attr&b.attr != 0 {
			lx.report.Err(a.Pos(), "invalid function specifier")
			break
		}

		lhs.attr = a.attr|b.attr
		lhs.typeSpecifier = b.typeSpecifier
		if lhs.IsTypedef() {
			lx.report.Err(a.Pos(), "invalid function specifier")
		}
	}

DeclarationSpecifiersOpt:
	/* empty */
	{
		$$ = (*DeclarationSpecifiersOpt)(nil)
		}
|	DeclarationSpecifiers
	{
		lhs := &DeclarationSpecifiersOpt{
			DeclarationSpecifiers:  $1.(*DeclarationSpecifiers),
		}
		$$ = lhs
		lhs.attr = lhs.DeclarationSpecifiers.attr
		lhs.typeSpecifier = lhs.DeclarationSpecifiers.typeSpecifier
	}

InitDeclaratorList:
	InitDeclarator
	{
		$$ = &InitDeclaratorList{
			InitDeclarator:  $1.(*InitDeclarator),
		}
	}
|	InitDeclaratorList ',' InitDeclarator
	{
		$$ = &InitDeclaratorList{
			Case:                1,
			InitDeclaratorList:  $1.(*InitDeclaratorList),
			Token:               $2,
			InitDeclarator:      $3.(*InitDeclarator),
		}
	}

InitDeclaratorListOpt:
	/* empty */
	{
		$$ = (*InitDeclaratorListOpt)(nil)
		}
|	InitDeclaratorList
	{
		$$ = &InitDeclaratorListOpt{
			InitDeclaratorList:  $1.(*InitDeclaratorList).reverse(),
		}
	}

InitDeclarator:
	Declarator
	{
		lx := yylex.(*lexer)
		lhs := &InitDeclarator{
			Declarator:  $1.(*Declarator),
		}
		$$ = lhs
		lhs.Declarator.setFull(lx)
	}
|	Declarator
	{
		lx := yylex.(*lexer)
		d := $1.(*Declarator)
		d.setFull(lx)
	}
	'=' Initializer
	{
		lx := yylex.(*lexer)
		lhs := &InitDeclarator{
			Case:         1,
			Declarator:   $1.(*Declarator),
			Token:        $3,
			Initializer:  $4.(*Initializer),
		}
		$$ = lhs
		switch i := lhs.Initializer; i.Case {
		case 0: // Expression
			s := i.Expression.Type
			d := lhs.Declarator.Type
			if !s.CanAssignTo(s) {
				lx.report.Err(i.Pos(), "incompatible types when initializing type '%s' using type â€˜%s'", d, s)
			}
		case 1: // '{' InitializerList CommaOpt '}'
			limit := -1
			var checkType Type
			var mb []Member
			d := lhs.Declarator
			k := d.Type.Kind()
			switch k {
			case Array:
				checkType = d.Type.Element()
				limit = d.Type.Elements()
			case Ptr:
				checkType = d.Type.Element()
				d.Type = d.Type.(*ctype).setElements(i.InitializerList.Len())
			case Struct, Union:
				mb, _ = d.Type.Members()
				if mb == nil {
					panic("internal error")
				}

				limit = len(mb)
				if k == Union {
					limit = 1
				}
			default:
				//dbg("", position(d.Pos()), d.Type.Kind())
				panic("TODO")
			}

			values := 0
			for l := i.InitializerList; l != nil; l = l.InitializerList {
				values++
				l.Initializer.typeCheck(checkType, mb, values-1, limit, lx)
			}
		default:
			panic(i.Case)
		}
	}

StorageClassSpecifier:
	"typedef"
	{
		lhs := &StorageClassSpecifier{
			Token:  $1,
		}
		$$ = lhs
		lhs.attr = saTypedef
	}
|	"extern"
	{
		lhs := &StorageClassSpecifier{
			Case:   1,
			Token:  $1,
		}
		$$ = lhs
		lhs.attr = saExtern
	}
|	"static"
	{
		lhs := &StorageClassSpecifier{
			Case:   2,
			Token:  $1,
		}
		$$ = lhs
		lhs.attr = saStatic
	}
|	"auto"
	{
		lhs := &StorageClassSpecifier{
			Case:   3,
			Token:  $1,
		}
		$$ = lhs
		lhs.attr = saAuto
	}
|	"register"
	{
		lhs := &StorageClassSpecifier{
			Case:   4,
			Token:  $1,
		}
		$$ = lhs
		lhs.attr = saRegister
	}

TypeSpecifier:
	"void"
	{
		lhs := &TypeSpecifier{
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsVoid)
	}
|	"char"
	{
		lhs := &TypeSpecifier{
			Case:   1,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsChar)
	}
|	"short"
	{
		lhs := &TypeSpecifier{
			Case:   2,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsShort)
	}
|	"int"
	{
		lhs := &TypeSpecifier{
			Case:   3,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsInt)
	}
|	"long"
	{
		lhs := &TypeSpecifier{
			Case:   4,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsLong)
	}
|	"float"
	{
		lhs := &TypeSpecifier{
			Case:   5,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsFloat)
	}
|	"double"
	{
		lhs := &TypeSpecifier{
			Case:   6,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsDouble)
	}
|	"signed"
	{
		lhs := &TypeSpecifier{
			Case:   7,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsSigned)
	}
|	"unsigned"
	{
		lhs := &TypeSpecifier{
			Case:   8,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsUnsigned)
	}
|	"_Bool"
	{
		lhs := &TypeSpecifier{
			Case:   9,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsBool)
	}
|	"_Complex"
	{
		lhs := &TypeSpecifier{
			Case:   10,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsComplex)
	}
|	StructOrUnionSpecifier
	{
		lhs := &TypeSpecifier{
			Case:                    11,
			StructOrUnionSpecifier:  $1.(*StructOrUnionSpecifier),
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(lhs.StructOrUnionSpecifier.typeSpecifiers())
	}
|	EnumSpecifier
	{
		lhs := &TypeSpecifier{
			Case:           12,
			EnumSpecifier:  $1.(*EnumSpecifier),
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsEnumSpecifier)
	}
|	TYPEDEFNAME
	{
		lx := yylex.(*lexer)
		lhs := &TypeSpecifier{
			Case:   13,
			Token:  $1,
		}
		$$ = lhs
		lhs.typeSpecifier = tsEncode(tsTypedefName)
		_, lhs.scope = lx.scope.Lookup2(NSIdentifiers, lhs.Token.Val)
	}

StructOrUnionSpecifier:
	StructOrUnion IdentifierOpt
	{
		lx := yylex.(*lexer)
		if o := $2.(*IdentifierOpt); o != nil {
			lx.scope.declareStructTag(o.Token, lx.report)
		}
	}
	'{'
	{
		lx := yylex.(*lexer)
		lx.pushScope(ScopeMembers)
		lx.scope.isUnion = $1.(*StructOrUnion).Case == 1 // "union"
		lx.scope.prevStructDeclarator = nil
	}
	StructDeclarationList '}'
	{
		lx := yylex.(*lexer)
		lhs := &StructOrUnionSpecifier{
			StructOrUnion:          $1.(*StructOrUnion),
			IdentifierOpt:          $2.(*IdentifierOpt),
			Token:                  $4,
			StructDeclarationList:  $6.(*StructDeclarationList).reverse(),
			Token2:                 $7,
		}
		$$ = lhs
		sc := lx.scope
		lhs.scope = sc
		if sc.bitOffset != 0 {
			finishBitField(lx)
		}

		i := 0
		var bt Type
		var d *Declarator
		for l := lhs.StructDeclarationList; l != nil; l = l.StructDeclarationList {
			for l := l.StructDeclaration.StructDeclaratorList; l != nil; l = l.StructDeclaratorList {
				switch sd := l.StructDeclarator; sd.Case {
				case 0: // Declarator
					d = sd.Declarator
				case 1: // DeclaratorOpt ':' ConstantExpression
					if o := sd.DeclaratorOpt; o != nil {
						x := o.Declarator
						if x.bitOffset == 0  {
							d = x
							bt = lx.scope.bitFieldTypes[i]
							i++
						}
						x.bitFieldType = bt
					}
				}
			}
		}
		lx.scope.bitFieldTypes = nil

		lhs.alignOf = sc.maxAlign
		switch {
		case sc.isUnion:
			lhs.sizeOf = align(sc.maxSize, sc.maxAlign)
		default:
			off := sc.offset
			lhs.sizeOf = align(sc.offset, sc.maxAlign)
			if d != nil {
				d.padding = lhs.sizeOf-off
			}
		}
		if lhs.sizeOf == 0 {
			panic("internal error")
		}

		lx.popScope(lhs.Token2)
		if o := lhs.IdentifierOpt; o != nil {
			lx.scope.defineStructTag(o.Token, lhs, lx.report)
		}
	}
|	StructOrUnion IDENTIFIER
	{
		lx := yylex.(*lexer)
		lhs := &StructOrUnionSpecifier{
			Case:           1,
			StructOrUnion:  $1.(*StructOrUnion),
			Token:          $2,
		}
		$$ = lhs
		lx.scope.declareStructTag(lhs.Token, lx.report)
		lhs.scope = lx.scope
	}

StructOrUnion:
	"struct"
	{
		$$ = &StructOrUnion{
			Token:  $1,
		}
	}
|	"union"
	{
		$$ = &StructOrUnion{
			Case:   1,
			Token:  $1,
		}
	}

StructDeclarationList:
	StructDeclaration
	{
		$$ = &StructDeclarationList{
			StructDeclaration:  $1.(*StructDeclaration),
		}
	}
|	StructDeclarationList StructDeclaration
	{
		$$ = &StructDeclarationList{
			Case:                   1,
			StructDeclarationList:  $1.(*StructDeclarationList),
			StructDeclaration:      $2.(*StructDeclaration),
		}
	}

StructDeclaration:
	SpecifierQualifierList StructDeclaratorList ';'
	{
		$$ = &StructDeclaration{
			SpecifierQualifierList:  $1.(*SpecifierQualifierList),
			StructDeclaratorList:    $2.(*StructDeclaratorList).reverse(),
			Token:                   $3,
		}
	}

SpecifierQualifierList:
	TypeSpecifier SpecifierQualifierListOpt
	{
		lx := yylex.(*lexer)
		lhs := &SpecifierQualifierList{
			TypeSpecifier:              $1.(*TypeSpecifier),
			SpecifierQualifierListOpt:  $2.(*SpecifierQualifierListOpt),
		}
		$$ = lhs
		lx.scope.specifier = lhs
		a := lhs.TypeSpecifier
		b := lhs.SpecifierQualifierListOpt
		if b == nil {
			lhs.typeSpecifier = a.typeSpecifier
			break
		}

		lhs.attr = b.attr
		ts := tsEncode(append(tsDecode(a.typeSpecifier), tsDecode(b.typeSpecifier)...)...)
		if _, ok := tsValid[ts]; !ok {
			lx.report.Err(a.Pos(), "invalid type specifier")
			break
		}

		lhs.typeSpecifier = ts
	}
|	TypeQualifier SpecifierQualifierListOpt
	{
		lx := yylex.(*lexer)
		lhs := &SpecifierQualifierList{
			Case:                       1,
			TypeQualifier:              $1.(*TypeQualifier),
			SpecifierQualifierListOpt:  $2.(*SpecifierQualifierListOpt),
		}
		$$ = lhs
		lx.scope.specifier = lhs
		a := lhs.TypeQualifier
		b := lhs.SpecifierQualifierListOpt
		if b == nil {
			lhs.attr = a.attr
			break
		}
	
		if a.attr&b.attr != 0 {
			lx.report.Err(a.Pos(), "invalid type qualifier")
			break
		}

		lhs.attr = a.attr|b.attr
		lhs.typeSpecifier = b.typeSpecifier
	}

SpecifierQualifierListOpt:
	/* empty */
	{
		$$ = (*SpecifierQualifierListOpt)(nil)
		}
|	SpecifierQualifierList
	{
		lhs := &SpecifierQualifierListOpt{
			SpecifierQualifierList:  $1.(*SpecifierQualifierList),
		}
		$$ = lhs
		lhs.attr = lhs.SpecifierQualifierList.attr
		lhs.typeSpecifier = lhs.SpecifierQualifierList.typeSpecifier
	}

StructDeclaratorList:
	StructDeclarator
	{
		$$ = &StructDeclaratorList{
			StructDeclarator:  $1.(*StructDeclarator),
		}
	}
|	StructDeclaratorList ',' StructDeclarator
	{
		$$ = &StructDeclaratorList{
			Case:                  1,
			StructDeclaratorList:  $1.(*StructDeclaratorList),
			Token:                 $2,
			StructDeclarator:      $3.(*StructDeclarator),
		}
	}

StructDeclarator:
	Declarator
	{
		lx := yylex.(*lexer)
		lhs := &StructDeclarator{
			Declarator:  $1.(*Declarator),
		}
		$$ = lhs
		lhs.Declarator.setFull(lx)
		lhs.post(lx)
	}
|	DeclaratorOpt ':' ConstantExpression
	{
		lx := yylex.(*lexer)
		lhs := &StructDeclarator{
			Case:                1,
			DeclaratorOpt:       $1.(*DeclaratorOpt),
			Token:               $2,
			ConstantExpression:  $3.(*ConstantExpression),
		}
		$$ = lhs
		m := lx.model
		e := lhs.ConstantExpression
		if e.Value == nil {
			e.Value, e.Type = m.value2(1, m.IntType)
		}
		if e.Type.Kind() != Int {
			lx.report.Err(e.Pos(), "bit field width not an integer")
			e.Value, e.Type = m.value2(1, m.IntType)
		}
		if o := lhs.DeclaratorOpt; o != nil {
			o.Declarator.setFull(lx)
		}
		lhs.post(lx)
	}

CommaOpt:
	/* empty */
	{
		$$ = (*CommaOpt)(nil)
		}
|	','
	{
		$$ = &CommaOpt{
			Token:  $1,
		}
	}

EnumSpecifier:
	"enum" IdentifierOpt
	{
		lx := yylex.(*lexer)
		if o := $2.(*IdentifierOpt); o != nil {
			lx.scope.declareEnumTag(o.Token, lx.report)
		}
		lx.iota = 0
	}
	'{' EnumeratorList CommaOpt '}'
	{
		lx := yylex.(*lexer)
		lhs := &EnumSpecifier{
			Token:           $1,
			IdentifierOpt:   $2.(*IdentifierOpt),
			Token2:          $4,
			EnumeratorList:  $5.(*EnumeratorList).reverse(),
			CommaOpt:        $6.(*CommaOpt),
			Token3:          $7,
		}
		$$ = lhs
		if o := lhs.IdentifierOpt; o != nil {
			lx.scope.defineEnumTag(o.Token, lhs, lx.report)
		}
	}
|	"enum" IDENTIFIER
	{
		lx := yylex.(*lexer)
		lhs := &EnumSpecifier{
			Case:    1,
			Token:   $1,
			Token2:  $2,
		}
		$$ = lhs
		lx.scope.declareEnumTag(lhs.Token2, lx.report)
	}

EnumeratorList:
	Enumerator
	{
		$$ = &EnumeratorList{
			Enumerator:  $1.(*Enumerator),
		}
	}
|	EnumeratorList ',' Enumerator
	{
		$$ = &EnumeratorList{
			Case:            1,
			EnumeratorList:  $1.(*EnumeratorList),
			Token:           $2,
			Enumerator:      $3.(*Enumerator),
		}
	}

Enumerator:
	EnumerationConstant
	{
		lx := yylex.(*lexer)
		lhs := &Enumerator{
			EnumerationConstant:  $1.(*EnumerationConstant),
		}
		$$ = lhs
		lx.scope.defineEnumConst(lx, lhs.EnumerationConstant.Token, lx.iota)
	}
|	EnumerationConstant '=' ConstantExpression
	{
		lx := yylex.(*lexer)
		lhs := &Enumerator{
			Case:                 1,
			EnumerationConstant:  $1.(*EnumerationConstant),
			Token:                $2,
			ConstantExpression:   $3.(*ConstantExpression),
		}
		$$ = lhs
		m := lx.model
		e := lhs.ConstantExpression
		if e.Type.Kind() != Int {
			lx.report.Err(e.Pos(), "not an integer constant expression (have '%s')", e.Type)
			e.Value, e.Type = m.value2(1, m.IntType)
			break
		}

		var val int
		switch x := e.Value.(type) {
		case int16:
			val = int(x)
		case int32:
			val = int(x)
		case int64:
			val = int(x)
		default:
			panic("internal error")
		}
		lx.scope.defineEnumConst(lx, lhs.EnumerationConstant.Token, val)
	}

TypeQualifier:
	"const"
	{
		lhs := &TypeQualifier{
			Token:  $1,
		}
		$$ = lhs
		lhs.attr = saConst
	}
|	"restrict"
	{
		lhs := &TypeQualifier{
			Case:   1,
			Token:  $1,
		}
		$$ = lhs
		lhs.attr = saRestrict
	}
|	"volatile"
	{
		lhs := &TypeQualifier{
			Case:   2,
			Token:  $1,
		}
		$$ = lhs
		lhs.attr = saVolatile
	}

FunctionSpecifier:
	"inline"
	{
		lhs := &FunctionSpecifier{
			Token:  $1,
		}
		$$ = lhs
		lhs.attr = saInline
	}

Declarator:
	PointerOpt DirectDeclarator
	{
		lx := yylex.(*lexer)
		lhs := &Declarator{
			PointerOpt:        $1.(*PointerOpt),
			DirectDeclarator:  $2.(*DirectDeclarator),
		}
		$$ = lhs
		lhs.specifier = lx.scope.specifier
		lhs.DirectDeclarator.declarator = lhs
	}

DeclaratorOpt:
	/* empty */
	{
		$$ = (*DeclaratorOpt)(nil)
		}
|	Declarator
	{
		$$ = &DeclaratorOpt{
			Declarator:  $1.(*Declarator),
		}
	}

DirectDeclarator:
	IDENTIFIER
	{
		lx := yylex.(*lexer)
		lhs := &DirectDeclarator{
			Token:  $1,
		}
		$$ = lhs
		lhs.specifier = lx.scope.specifier
		lx.scope.declareIdentifier(lhs.Token, lhs, lx.report)
		lhs.idScope = lx.scope
	}
|	'(' Declarator ')'
	{
		lhs := &DirectDeclarator{
			Case:        1,
			Token:       $1,
			Declarator:  $2.(*Declarator),
			Token2:      $3,
		}
		$$ = lhs
		lhs.Declarator.specifier = nil
		lhs.Declarator.DirectDeclarator.parent = lhs
	}
|	DirectDeclarator '[' TypeQualifierListOpt ExpressionOpt ']'
	{
		lx := yylex.(*lexer)
		lhs := &DirectDeclarator{
			Case:                  2,
			DirectDeclarator:      $1.(*DirectDeclarator),
			Token:                 $2,
			TypeQualifierListOpt:  $3.(*TypeQualifierListOpt),
			ExpressionOpt:         $4.(*ExpressionOpt),
			Token2:                $5,
		}
		$$ = lhs
		lhs.elements = -1
		if o := lhs.ExpressionOpt; o != nil {
			o.Expression.eval(lx.model)
			var err error
			if lhs.elements, err = elements(o.Expression.Value); err != nil {
				lx.report.Err(o.Expression.Pos(), "%s", err)
			}
			
		}
		lhs.DirectDeclarator.parent = lhs
	}
|	DirectDeclarator '[' "static" TypeQualifierListOpt Expression ']'
	{
		lx := yylex.(*lexer)
		lhs := &DirectDeclarator{
			Case:                  3,
			DirectDeclarator:      $1.(*DirectDeclarator),
			Token:                 $2,
			Token2:                $3,
			TypeQualifierListOpt:  $4.(*TypeQualifierListOpt),
			Expression:            $5.(*Expression),
			Token3:                $6,
		}
		$$ = lhs
		lhs.Expression.eval(lx.model)
		var err error
		if lhs.elements, err = elements(lhs.Expression.Value); err != nil {
			lx.report.Err(lhs.Expression.Pos(), "%s", err)
		}
		lhs.DirectDeclarator.parent = lhs
	}
|	DirectDeclarator '[' TypeQualifierList "static" Expression ']'
	{
		lx := yylex.(*lexer)
		lhs := &DirectDeclarator{
			Case:               4,
			DirectDeclarator:   $1.(*DirectDeclarator),
			Token:              $2,
			TypeQualifierList:  $3.(*TypeQualifierList).reverse(),
			Token2:             $4,
			Expression:         $5.(*Expression),
			Token3:             $6,
		}
		$$ = lhs
		lhs.Expression.eval(lx.model)
		var err error
		if lhs.elements, err = elements(lhs.Expression.Value); err != nil {
			lx.report.Err(lhs.Expression.Pos(), "%s", err)
		}
		lhs.DirectDeclarator.parent = lhs
	}
|	DirectDeclarator '[' TypeQualifierListOpt '*' ']'
	{
		lhs := &DirectDeclarator{
			Case:                  5,
			DirectDeclarator:      $1.(*DirectDeclarator),
			Token:                 $2,
			TypeQualifierListOpt:  $3.(*TypeQualifierListOpt),
			Token2:                $4,
			Token3:                $5,
		}
		$$ = lhs
		lhs.DirectDeclarator.parent = lhs
		lhs.elements = -1
	}
|	DirectDeclarator '('
	{
		lx := yylex.(*lexer)
		lx.pushScope(ScopeParams)
	}
	ParameterTypeList ')'
	{
		lx := yylex.(*lexer)
		lhs := &DirectDeclarator{
			Case:               6,
			DirectDeclarator:   $1.(*DirectDeclarator),
			Token:              $2,
			ParameterTypeList:  $4.(*ParameterTypeList),
			Token2:             $5,
		}
		$$ = lhs
		lhs.paramsScope, _ = lx.popScope(lhs.Token2)
		lhs.DirectDeclarator.parent = lhs
	}
|	DirectDeclarator '(' IdentifierListOpt ')'
	{
		lhs := &DirectDeclarator{
			Case:               7,
			DirectDeclarator:   $1.(*DirectDeclarator),
			Token:              $2,
			IdentifierListOpt:  $3.(*IdentifierListOpt),
			Token2:             $4,
		}
		$$ = lhs
		lhs.DirectDeclarator.parent = lhs
	}

Pointer:
	'*' TypeQualifierListOpt
	{
		$$ = &Pointer{
			Token:                 $1,
			TypeQualifierListOpt:  $2.(*TypeQualifierListOpt),
		}
	}
|	'*' TypeQualifierListOpt Pointer
	{
		$$ = &Pointer{
			Case:                  1,
			Token:                 $1,
			TypeQualifierListOpt:  $2.(*TypeQualifierListOpt),
			Pointer:               $3.(*Pointer),
		}
	}

PointerOpt:
	/* empty */
	{
		$$ = (*PointerOpt)(nil)
		}
|	Pointer
	{
		$$ = &PointerOpt{
			Pointer:  $1.(*Pointer),
		}
	}

TypeQualifierList:
	TypeQualifier
	{
		lhs := &TypeQualifierList{
			TypeQualifier:  $1.(*TypeQualifier),
		}
		$$ = lhs
		lhs.attr = lhs.TypeQualifier.attr
	}
|	TypeQualifierList TypeQualifier
	{
		lx := yylex.(*lexer)
		lhs := &TypeQualifierList{
			Case:               1,
			TypeQualifierList:  $1.(*TypeQualifierList),
			TypeQualifier:      $2.(*TypeQualifier),
		}
		$$ = lhs
		a := lhs.TypeQualifierList
		b := lhs.TypeQualifier
		if a.attr&b.attr != 0 {
			lx.report.Err(b.Pos(), "invalid type qualifier")
			break
		}

		lhs.attr = a.attr|b.attr
	}

TypeQualifierListOpt:
	/* empty */
	{
		$$ = (*TypeQualifierListOpt)(nil)
		}
|	TypeQualifierList
	{
		$$ = &TypeQualifierListOpt{
			TypeQualifierList:  $1.(*TypeQualifierList).reverse(),
		}
	}

ParameterTypeList:
	ParameterList
	{
		lhs := &ParameterTypeList{
			ParameterList:  $1.(*ParameterList).reverse(),
		}
		$$ = lhs
		lhs.post()
	}
|	ParameterList ',' "..."
	{
		lhs := &ParameterTypeList{
			Case:           1,
			ParameterList:  $1.(*ParameterList).reverse(),
			Token:          $2,
			Token2:         $3,
		}
		$$ = lhs
		lhs.post()
	}

ParameterTypeListOpt:
	/* empty */
	{
		$$ = (*ParameterTypeListOpt)(nil)
		}
|	ParameterTypeList
	{
		$$ = &ParameterTypeListOpt{
			ParameterTypeList:  $1.(*ParameterTypeList),
		}
	}

ParameterList:
	ParameterDeclaration
	{
		$$ = &ParameterList{
			ParameterDeclaration:  $1.(*ParameterDeclaration),
		}
	}
|	ParameterList ',' ParameterDeclaration
	{
		$$ = &ParameterList{
			Case:                  1,
			ParameterList:         $1.(*ParameterList),
			Token:                 $2,
			ParameterDeclaration:  $3.(*ParameterDeclaration),
		}
	}

ParameterDeclaration:
	DeclarationSpecifiers Declarator
	{
		lx := yylex.(*lexer)
		lhs := &ParameterDeclaration{
			DeclarationSpecifiers:  $1.(*DeclarationSpecifiers),
			Declarator:             $2.(*Declarator),
		}
		$$ = lhs
		lhs.Declarator.setFull(lx)
		lhs.declarator = lhs.Declarator
	}
|	DeclarationSpecifiers AbstractDeclaratorOpt
	{
		lx := yylex.(*lexer)
		lhs := &ParameterDeclaration{
			Case:                   1,
			DeclarationSpecifiers:  $1.(*DeclarationSpecifiers),
			AbstractDeclaratorOpt:  $2.(*AbstractDeclaratorOpt),
		}
		$$ = lhs
		if o := lhs.AbstractDeclaratorOpt; o != nil {
			lhs.declarator = o.AbstractDeclarator.declarator
			lhs.declarator.setFull(lx)
			break
		}

		d := &Declarator{
			specifier: lx.scope.specifier,
			DirectDeclarator: &DirectDeclarator{
				Case: 0, // IDENTIFIER
			},
		}
		d.DirectDeclarator.declarator = d
		lhs.declarator = d
		d.setFull(lx)
	}

IdentifierList:
	IDENTIFIER
	{
		$$ = &IdentifierList{
			Token:  $1,
		}
	}
|	IdentifierList ',' IDENTIFIER
	{
		$$ = &IdentifierList{
			Case:            1,
			IdentifierList:  $1.(*IdentifierList),
			Token:           $2,
			Token2:          $3,
		}
	}

IdentifierListOpt:
	/* empty */
	{
		$$ = (*IdentifierListOpt)(nil)
		}
|	IdentifierList
	{
		$$ = &IdentifierListOpt{
			IdentifierList:  $1.(*IdentifierList).reverse(),
		}
	}

IdentifierOpt:
	/* empty */
	{
		$$ = (*IdentifierOpt)(nil)
		}
|	IDENTIFIER
	{
		$$ = &IdentifierOpt{
			Token:  $1,
		}
	}

TypeName:
	{
		lx := yylex.(*lexer)
		lx.pushScope(ScopeBlock)
	}
	SpecifierQualifierList AbstractDeclaratorOpt
	{
		lx := yylex.(*lexer)
		lhs := &TypeName{
			SpecifierQualifierList:  $2.(*SpecifierQualifierList),
			AbstractDeclaratorOpt:   $3.(*AbstractDeclaratorOpt),
		}
		$$ = lhs
		if o := lhs.AbstractDeclaratorOpt; o != nil {
			lhs.declarator = o.AbstractDeclarator.declarator
		} else {
			d := &Declarator{
				specifier: lhs.SpecifierQualifierList,
				DirectDeclarator: &DirectDeclarator{
					Case: 0, // IDENTIFIER
					idScope: lx.scope,
				},
			}
			d.DirectDeclarator.declarator = d
			lhs.declarator = d
		}
		lhs.Type = lhs.declarator.setFull(lx)
		lx.popScope(xc.Token{})
	}

AbstractDeclarator:
	Pointer
	{
		lx := yylex.(*lexer)
		lhs := &AbstractDeclarator{
			Pointer:  $1.(*Pointer),
		}
		$$ = lhs
		d := &Declarator{
			specifier: lx.scope.specifier,
			PointerOpt: &PointerOpt {
				Pointer: lhs.Pointer,
			},
			DirectDeclarator: &DirectDeclarator{
				Case: 0, // IDENTIFIER
				idScope: lx.scope,
			},
		}
		d.DirectDeclarator.declarator = d
		lhs.declarator = d
	}
|	PointerOpt DirectAbstractDeclarator
	{
		lx := yylex.(*lexer)
		lhs := &AbstractDeclarator{
			Case:                      1,
			PointerOpt:                $1.(*PointerOpt),
			DirectAbstractDeclarator:  $2.(*DirectAbstractDeclarator),
		}
		$$ = lhs
		d := &Declarator{
			specifier: lx.scope.specifier,
			PointerOpt: lhs.PointerOpt,
			DirectDeclarator: lhs.DirectAbstractDeclarator.directDeclarator,
		}
		d.DirectDeclarator.declarator = d
		lhs.declarator = d
	}

AbstractDeclaratorOpt:
	/* empty */
	{
		$$ = (*AbstractDeclaratorOpt)(nil)
		}
|	AbstractDeclarator
	{
		$$ = &AbstractDeclaratorOpt{
			AbstractDeclarator:  $1.(*AbstractDeclarator),
		}
	}

DirectAbstractDeclarator:
	'(' AbstractDeclarator ')'
	{
		lhs := &DirectAbstractDeclarator{
			Token:               $1,
			AbstractDeclarator:  $2.(*AbstractDeclarator),
			Token2:              $3,
		}
		$$ = lhs
		lhs.AbstractDeclarator.declarator.specifier = nil
		lhs.directDeclarator = &DirectDeclarator{
			Case: 1, // '(' Declarator ')'
			Declarator: lhs.AbstractDeclarator.declarator,
		}
		lhs.AbstractDeclarator.declarator.DirectDeclarator.parent = lhs.directDeclarator
	}
|	DirectAbstractDeclaratorOpt '[' ExpressionOpt ']'
	{
		lx := yylex.(*lexer)
		lhs := &DirectAbstractDeclarator{
			Case:                         1,
			DirectAbstractDeclaratorOpt:  $1.(*DirectAbstractDeclaratorOpt),
			Token:                        $2,
			ExpressionOpt:                $3.(*ExpressionOpt),
			Token2:                       $4,
		}
		$$ = lhs
		if o := lhs.ExpressionOpt; o != nil {
			o.Expression.eval(lx.model)
		}
		var dd *DirectDeclarator
		switch o := lhs.DirectAbstractDeclaratorOpt; {
		case o == nil:
			dd = &DirectDeclarator{
				Case: 0, // IDENTIFIER
			}
		default:
			dd = o.DirectAbstractDeclarator.directDeclarator
		}
		lhs.directDeclarator = &DirectDeclarator{
			Case: 2, // DirectDeclarator '[' TypeQualifierListOpt ExpressionOpt ']'
			DirectDeclarator: dd,
			ExpressionOpt: lhs.ExpressionOpt,
		}
		dd.parent = lhs.directDeclarator
	}
|	DirectAbstractDeclaratorOpt '[' TypeQualifierList ExpressionOpt ']'
	{
		lx := yylex.(*lexer)
		lhs := &DirectAbstractDeclarator{
			Case:                         2,
			DirectAbstractDeclaratorOpt:  $1.(*DirectAbstractDeclaratorOpt),
			Token:                        $2,
			TypeQualifierList:            $3.(*TypeQualifierList).reverse(),
			ExpressionOpt:                $4.(*ExpressionOpt),
			Token2:                       $5,
		}
		$$ = lhs
		if o := lhs.ExpressionOpt; o != nil {
			o.Expression.eval(lx.model)
		}
		var dd *DirectDeclarator
		switch o := lhs.DirectAbstractDeclaratorOpt; {
		case o == nil:
			dd = &DirectDeclarator{
				Case: 0, // IDENTIFIER
			}
		default:
			dd = o.DirectAbstractDeclarator.directDeclarator
		}
		lhs.directDeclarator = &DirectDeclarator{
			Case: 2, // DirectDeclarator '[' TypeQualifierListOpt ExpressionOpt ']'
			DirectDeclarator: dd,
			TypeQualifierListOpt: &TypeQualifierListOpt{ lhs.TypeQualifierList },
			ExpressionOpt: lhs.ExpressionOpt,
		}
		dd.parent = lhs.directDeclarator
	}
|	DirectAbstractDeclaratorOpt '[' "static" TypeQualifierListOpt Expression ']'
	{
		lx := yylex.(*lexer)
		lhs := &DirectAbstractDeclarator{
			Case:                         3,
			DirectAbstractDeclaratorOpt:  $1.(*DirectAbstractDeclaratorOpt),
			Token:                        $2,
			Token2:                       $3,
			TypeQualifierListOpt:         $4.(*TypeQualifierListOpt),
			Expression:                   $5.(*Expression),
			Token3:                       $6,
		}
		$$ = lhs
		lhs.Expression.eval(lx.model)
		var dd *DirectDeclarator
		switch o := lhs.DirectAbstractDeclaratorOpt; {
		case o == nil:
			dd = &DirectDeclarator{
				Case: 0, // IDENTIFIER
			}
		default:
			dd = o.DirectAbstractDeclarator.directDeclarator
		}
		lhs.directDeclarator = &DirectDeclarator{
			Case: 2, // DirectDeclarator '[' "static" TypeQualifierListOpt Expression ']'
			DirectDeclarator: dd,
			TypeQualifierListOpt: lhs.TypeQualifierListOpt,
			Expression: lhs.Expression,
		}
		dd.parent = lhs.directDeclarator
	}
|	DirectAbstractDeclaratorOpt '[' TypeQualifierList "static" Expression ']'
	{
		lx := yylex.(*lexer)
		lhs := &DirectAbstractDeclarator{
			Case:                         4,
			DirectAbstractDeclaratorOpt:  $1.(*DirectAbstractDeclaratorOpt),
			Token:                        $2,
			TypeQualifierList:            $3.(*TypeQualifierList).reverse(),
			Token2:                       $4,
			Expression:                   $5.(*Expression),
			Token3:                       $6,
		}
		$$ = lhs
		lhs.Expression.eval(lx.model)
		var dd *DirectDeclarator
		switch o := lhs.DirectAbstractDeclaratorOpt; {
		case o == nil:
			dd = &DirectDeclarator{
				Case: 0, // IDENTIFIER
			}
		default:
			dd = o.DirectAbstractDeclarator.directDeclarator
		}
		lhs.directDeclarator = &DirectDeclarator{
			Case: 4, // DirectDeclarator '[' TypeQualifierList "static" Expression ']'
			DirectDeclarator: dd,
			TypeQualifierList: lhs.TypeQualifierList,
			Expression: lhs.Expression,
		}
		dd.parent = lhs.directDeclarator
	}
|	DirectAbstractDeclaratorOpt '[' '*' ']'
	{
		lhs := &DirectAbstractDeclarator{
			Case:                         5,
			DirectAbstractDeclaratorOpt:  $1.(*DirectAbstractDeclaratorOpt),
			Token:                        $2,
			Token2:                       $3,
			Token3:                       $4,
		}
		$$ = lhs
		var dd *DirectDeclarator
		switch o := lhs.DirectAbstractDeclaratorOpt; {
		case o == nil:
			dd = &DirectDeclarator{
				Case: 0, // IDENTIFIER
			}
		default:
			dd = o.DirectAbstractDeclarator.directDeclarator
		}
		lhs.directDeclarator = &DirectDeclarator{
			Case: 5, // DirectDeclarator '[' TypeQualifierListOpt '*' ']'
			DirectDeclarator: dd,
		}
		dd.parent = lhs.directDeclarator
	}
|	'('
	{
		lx := yylex.(*lexer)
		lx.pushScope(ScopeParams)
	}
	ParameterTypeListOpt ')'
	{
		lx := yylex.(*lexer)
		lhs := &DirectAbstractDeclarator{
			Case:                  6,
			Token:                 $1,
			ParameterTypeListOpt:  $3.(*ParameterTypeListOpt),
			Token2:                $4,
		}
		$$ = lhs
		lhs.paramsScope, _ = lx.popScope(lhs.Token2)
		switch o := lhs.ParameterTypeListOpt; {
		case o != nil:
			lhs.directDeclarator = &DirectDeclarator{
				Case: 6, // DirectDeclarator '(' ParameterTypeList ')'
				DirectDeclarator: &DirectDeclarator{
					Case: 0, // IDENTIFIER
				},
				ParameterTypeList: o.ParameterTypeList,
			}
		default:
			lhs.directDeclarator = &DirectDeclarator{
				Case: 7, // DirectDeclarator '(' IdentifierListOpt ')'
				DirectDeclarator: &DirectDeclarator{
					Case: 0, // IDENTIFIER
				},
			}
		}
		lhs.directDeclarator.DirectDeclarator.parent = lhs.directDeclarator
	}
|	DirectAbstractDeclarator '('
	{
		lx := yylex.(*lexer)
		lx.pushScope(ScopeParams)
	}
	ParameterTypeListOpt ')'
	{
		lx := yylex.(*lexer)
		lhs := &DirectAbstractDeclarator{
			Case:                      7,
			DirectAbstractDeclarator:  $1.(*DirectAbstractDeclarator),
			Token:                     $2,
			ParameterTypeListOpt:      $4.(*ParameterTypeListOpt),
			Token2:                    $5,
		}
		$$ = lhs
		lhs.paramsScope, _ = lx.popScope(lhs.Token2)
		switch o := lhs.ParameterTypeListOpt; {
		case o != nil:
			lhs.directDeclarator = &DirectDeclarator{
				Case: 6, // DirectDeclarator '(' ParameterTypeList ')'
				DirectDeclarator: lhs.DirectAbstractDeclarator.directDeclarator,
				ParameterTypeList: o.ParameterTypeList,
			}
		default:
			lhs.directDeclarator = &DirectDeclarator{
				Case: 7, // DirectDeclarator '(' IdentifierListOpt ')'
				DirectDeclarator: lhs.DirectAbstractDeclarator.directDeclarator,
			}
		}
		lhs.directDeclarator.DirectDeclarator.parent = lhs.directDeclarator
	}

DirectAbstractDeclaratorOpt:
	/* empty */
	{
		$$ = (*DirectAbstractDeclaratorOpt)(nil)
		}
|	DirectAbstractDeclarator
	{
		$$ = &DirectAbstractDeclaratorOpt{
			DirectAbstractDeclarator:  $1.(*DirectAbstractDeclarator),
		}
	}

Initializer:
	Expression
	{
		lx := yylex.(*lexer)
		lhs := &Initializer{
			Expression:  $1.(*Expression),
		}
		$$ = lhs
		lhs.Expression.eval(lx.model)
	}
|	'{' InitializerList CommaOpt '}'
	{
		$$ = &Initializer{
			Case:             1,
			Token:            $1,
			InitializerList:  $2.(*InitializerList).reverse(),
			CommaOpt:         $3.(*CommaOpt),
			Token2:           $4,
		}
	}

InitializerList:
	DesignationOpt Initializer
	{
		$$ = &InitializerList{
			DesignationOpt:  $1.(*DesignationOpt),
			Initializer:     $2.(*Initializer),
		}
	}
|	InitializerList ',' DesignationOpt Initializer
	{
		$$ = &InitializerList{
			Case:             1,
			InitializerList:  $1.(*InitializerList),
			Token:            $2,
			DesignationOpt:   $3.(*DesignationOpt),
			Initializer:      $4.(*Initializer),
		}
	}

Designation:
	DesignatorList '='
	{
		$$ = &Designation{
			DesignatorList:  $1.(*DesignatorList).reverse(),
			Token:           $2,
		}
	}

DesignationOpt:
	/* empty */
	{
		$$ = (*DesignationOpt)(nil)
		}
|	Designation
	{
		$$ = &DesignationOpt{
			Designation:  $1.(*Designation),
		}
	}

DesignatorList:
	Designator
	{
		$$ = &DesignatorList{
			Designator:  $1.(*Designator),
		}
	}
|	DesignatorList Designator
	{
		$$ = &DesignatorList{
			Case:            1,
			DesignatorList:  $1.(*DesignatorList),
			Designator:      $2.(*Designator),
		}
	}

Designator:
	'[' ConstantExpression ']'
	{
		$$ = &Designator{
			Token:               $1,
			ConstantExpression:  $2.(*ConstantExpression),
			Token2:              $3,
		}
	}
|	'.' IDENTIFIER
	{
		$$ = &Designator{
			Case:    1,
			Token:   $1,
			Token2:  $2,
		}
	}

Statement:
	LabeledStatement
	{
		$$ = &Statement{
			LabeledStatement:  $1.(*LabeledStatement),
		}
	}
|	CompoundStatement
	{
		$$ = &Statement{
			Case:               1,
			CompoundStatement:  $1.(*CompoundStatement),
		}
	}
|	ExpressionStatement
	{
		$$ = &Statement{
			Case:                 2,
			ExpressionStatement:  $1.(*ExpressionStatement),
		}
	}
|	SelectionStatement
	{
		$$ = &Statement{
			Case:                3,
			SelectionStatement:  $1.(*SelectionStatement),
		}
	}
|	IterationStatement
	{
		$$ = &Statement{
			Case:                4,
			IterationStatement:  $1.(*IterationStatement),
		}
	}
|	JumpStatement
	{
		$$ = &Statement{
			Case:           5,
			JumpStatement:  $1.(*JumpStatement),
		}
	}

LabeledStatement:
	IDENTIFIER ':' Statement
	{
		$$ = &LabeledStatement{
			Token:      $1,
			Token2:     $2,
			Statement:  $3.(*Statement),
		}
	}
|	"case" ConstantExpression ':' Statement
	{
		$$ = &LabeledStatement{
			Case:                1,
			Token:               $1,
			ConstantExpression:  $2.(*ConstantExpression),
			Token2:              $3,
			Statement:           $4.(*Statement),
		}
	}
|	"default" ':' Statement
	{
		$$ = &LabeledStatement{
			Case:       2,
			Token:      $1,
			Token2:     $2,
			Statement:  $3.(*Statement),
		}
	}

CompoundStatement:
	'{'
	{
		lx := yylex.(*lexer)
		m := lx.scope.mergeScope
		lx.pushScope(ScopeBlock)
		if m != nil {
			lx.scope.merge(m)
		}
		lx.scope.mergeScope = nil
	}
	BlockItemListOpt '}'
	{
		lx := yylex.(*lexer)
		lhs := &CompoundStatement{
			Token:             $1,
			BlockItemListOpt:  $3.(*BlockItemListOpt),
			Token2:            $4,
		}
		$$ = lhs
		lhs.scope = lx.scope
		lx.popScope(lhs.Token2)
	}

BlockItemList:
	BlockItem
	{
		$$ = &BlockItemList{
			BlockItem:  $1.(*BlockItem),
		}
	}
|	BlockItemList BlockItem
	{
		$$ = &BlockItemList{
			Case:           1,
			BlockItemList:  $1.(*BlockItemList),
			BlockItem:      $2.(*BlockItem),
		}
	}

BlockItemListOpt:
	/* empty */
	{
		$$ = (*BlockItemListOpt)(nil)
		}
|	BlockItemList
	{
		$$ = &BlockItemListOpt{
			BlockItemList:  $1.(*BlockItemList).reverse(),
		}
	}

BlockItem:
	Declaration
	{
		$$ = &BlockItem{
			Declaration:  $1.(*Declaration),
		}
	}
|	Statement
	{
		$$ = &BlockItem{
			Case:       1,
			Statement:  $1.(*Statement),
		}
	}

ExpressionStatement:
	ExpressionListOpt ';'
	{
		$$ = &ExpressionStatement{
			ExpressionListOpt:  $1.(*ExpressionListOpt),
			Token:              $2,
		}
	}

SelectionStatement:
	"if" '(' ExpressionList ')' Statement %prec NOELSE
	{
		lx := yylex.(*lexer)
		lhs := &SelectionStatement{
			Token:           $1,
			Token2:          $2,
			ExpressionList:  $3.(*ExpressionList).reverse(),
			Token3:          $4,
			Statement:       $5.(*Statement),
		}
		$$ = lhs
		lhs.ExpressionList.eval(lx.model)
	}
|	"if" '(' ExpressionList ')' Statement "else" Statement
	{
		lx := yylex.(*lexer)
		lhs := &SelectionStatement{
			Case:            1,
			Token:           $1,
			Token2:          $2,
			ExpressionList:  $3.(*ExpressionList).reverse(),
			Token3:          $4,
			Statement:       $5.(*Statement),
			Token4:          $6,
			Statement2:      $7.(*Statement),
		}
		$$ = lhs
		lhs.ExpressionList.eval(lx.model)
	}
|	"switch" '(' ExpressionList ')' Statement
	{
		lx := yylex.(*lexer)
		lhs := &SelectionStatement{
			Case:            2,
			Token:           $1,
			Token2:          $2,
			ExpressionList:  $3.(*ExpressionList).reverse(),
			Token3:          $4,
			Statement:       $5.(*Statement),
		}
		$$ = lhs
		lhs.ExpressionList.eval(lx.model)
	}

IterationStatement:
	"while" '(' ExpressionList ')' Statement
	{
		lx := yylex.(*lexer)
		lhs := &IterationStatement{
			Token:           $1,
			Token2:          $2,
			ExpressionList:  $3.(*ExpressionList).reverse(),
			Token3:          $4,
			Statement:       $5.(*Statement),
		}
		$$ = lhs
		lhs.ExpressionList.eval(lx.model)
	}
|	"do" Statement "while" '(' ExpressionList ')' ';'
	{
		lx := yylex.(*lexer)
		lhs := &IterationStatement{
			Case:            1,
			Token:           $1,
			Statement:       $2.(*Statement),
			Token2:          $3,
			Token3:          $4,
			ExpressionList:  $5.(*ExpressionList).reverse(),
			Token4:          $6,
			Token5:          $7,
		}
		$$ = lhs
		lhs.ExpressionList.eval(lx.model)
	}
|	"for" '(' ExpressionListOpt ';' ExpressionListOpt ';' ExpressionListOpt ')' Statement
	{
		$$ = &IterationStatement{
			Case:                2,
			Token:               $1,
			Token2:              $2,
			ExpressionListOpt:   $3.(*ExpressionListOpt),
			Token3:              $4,
			ExpressionListOpt2:  $5.(*ExpressionListOpt),
			Token4:              $6,
			ExpressionListOpt3:  $7.(*ExpressionListOpt),
			Token5:              $8,
			Statement:           $9.(*Statement),
		}
	}
|	"for" '(' Declaration ExpressionListOpt ';' ExpressionListOpt ')' Statement
	{
		$$ = &IterationStatement{
			Case:                3,
			Token:               $1,
			Token2:              $2,
			Declaration:         $3.(*Declaration),
			ExpressionListOpt:   $4.(*ExpressionListOpt),
			Token3:              $5,
			ExpressionListOpt2:  $6.(*ExpressionListOpt),
			Token4:              $7,
			Statement:           $8.(*Statement),
		}
	}

JumpStatement:
	"goto" IDENTIFIER ';'
	{
		$$ = &JumpStatement{
			Token:   $1,
			Token2:  $2,
			Token3:  $3,
		}
	}
|	"continue" ';'
	{
		$$ = &JumpStatement{
			Case:    1,
			Token:   $1,
			Token2:  $2,
		}
	}
|	"break" ';'
	{
		$$ = &JumpStatement{
			Case:    2,
			Token:   $1,
			Token2:  $2,
		}
	}
|	"return" ExpressionListOpt ';'
	{
		$$ = &JumpStatement{
			Case:               3,
			Token:              $1,
			ExpressionListOpt:  $2.(*ExpressionListOpt),
			Token2:             $3,
		}
	}

TranslationUnit:
	ExternalDeclaration
	{
		$$ = &TranslationUnit{
			ExternalDeclaration:  $1.(*ExternalDeclaration),
		}
	}
|	TranslationUnit ExternalDeclaration
	{
		$$ = &TranslationUnit{
			Case:                 1,
			TranslationUnit:      $1.(*TranslationUnit),
			ExternalDeclaration:  $2.(*ExternalDeclaration),
		}
	}

ExternalDeclaration:
	FunctionDefinition
	{
		$$ = &ExternalDeclaration{
			FunctionDefinition:  $1.(*FunctionDefinition),
		}
	}
|	Declaration
	{
		$$ = &ExternalDeclaration{
			Case:         1,
			Declaration:  $1.(*Declaration),
		}
	}

FunctionDefinition:
	DeclarationSpecifiers Declarator DeclarationListOpt
	{
		lx := yylex.(*lexer)
		d := $2.(*Declarator)
		d.setFull(lx)
		if k := d.Type.Kind(); k != Function {
			lx.report.Err(d.Pos(), "declarator is not a function (have '%s': %v)", d.Type, k)
		}
		lx.scope.mergeScope = d.DirectDeclarator.paramsScope
	}
	CompoundStatement
	{
		lx := yylex.(*lexer)
		lhs := &FunctionDefinition{
			DeclarationSpecifiers:  $1.(*DeclarationSpecifiers),
			Declarator:             $2.(*Declarator),
			DeclarationListOpt:     $3.(*DeclarationListOpt),
			CompoundStatement:      $5.(*CompoundStatement),
		}
		$$ = lhs
		d := lhs.Declarator
		switch dd := d.DirectDeclarator; dd.Case {
		case 6: // DirectDeclarator '(' ParameterTypeList ')'
			if o := lhs.DeclarationListOpt; o != nil {
				lx.report.Err(o.Pos(), "declaration list not allowed in a function definition with parameter type list")
			}
		case 7: // DirectDeclarator '(' IdentifierListOpt ')'
			if o1, o2 := dd.IdentifierListOpt, lhs.DeclarationListOpt; o1 != nil && o2 == nil {
				lx.report.Err(o1.Pos(), "declaration list required in a function definition without a parameter type list")
			}
		default:
			lx.report.Err(lhs.Declarator.Pos(), "invalid function definition declarator")
		}
	}

DeclarationList:
	Declaration
	{
		$$ = &DeclarationList{
			Declaration:  $1.(*Declaration),
		}
	}
|	DeclarationList Declaration
	{
		$$ = &DeclarationList{
			Case:             1,
			DeclarationList:  $1.(*DeclarationList),
			Declaration:      $2.(*Declaration),
		}
	}

DeclarationListOpt:
	/* empty */
	{
		$$ = (*DeclarationListOpt)(nil)
		}
|	DeclarationList
	{
		$$ = &DeclarationListOpt{
			DeclarationList:  $1.(*DeclarationList).reverse(),
		}
	}

PreprocessingFile:
	GroupList
	{
		lx := yylex.(*lexer)
		lhs := &PreprocessingFile{
			GroupList:  $1.(*GroupList).reverse(),
		}
		$$ = lhs
		lhs.path = lx.file.Name()
	}

GroupList:
	GroupPart
	{
		$$ = &GroupList{
			GroupPart:  $1,
		}
	}
|	GroupList GroupPart
	{
		$$ = &GroupList{
			Case:       1,
			GroupList:  $1.(*GroupList),
			GroupPart:  $2,
		}
	}

GroupListOpt:
	/* empty */
	{
		$$ = (*GroupListOpt)(nil)
		}
|	GroupList
	{
		$$ = &GroupListOpt{
			GroupList:  $1.(*GroupList).reverse(),
		}
	}

GroupPart:
	ControlLine
	{
		$$ = $1.(node)
	}
|	IfSection
	{
		$$ = $1.(node)
	}
|	PPNONDIRECTIVE PPTokenList '\n'
	{
		$$ = $1
	}
|	TextLine
	{
		$$ = $1
	}

IfSection:
	IfGroup ElifGroupListOpt ElseGroupOpt EndifLine
	{
		$$ = &IfSection{
			IfGroup:           $1.(*IfGroup),
			ElifGroupListOpt:  $2.(*ElifGroupListOpt),
			ElseGroupOpt:      $3.(*ElseGroupOpt),
			EndifLine:         $4.(*EndifLine),
		}
	}

IfGroup:
	PPIF PPTokenList '\n' GroupListOpt
	{
		$$ = &IfGroup{
			Token:         $1,
			PPTokenList:   $2,
			Token2:        $3,
			GroupListOpt:  $4.(*GroupListOpt),
		}
	}
|	PPIFDEF IDENTIFIER '\n' GroupListOpt
	{
		$$ = &IfGroup{
			Case:          1,
			Token:         $1,
			Token2:        $2,
			Token3:        $3,
			GroupListOpt:  $4.(*GroupListOpt),
		}
	}
|	PPIFNDEF IDENTIFIER '\n' GroupListOpt
	{
		$$ = &IfGroup{
			Case:          2,
			Token:         $1,
			Token2:        $2,
			Token3:        $3,
			GroupListOpt:  $4.(*GroupListOpt),
		}
	}

ElifGroupList:
	ElifGroup
	{
		$$ = &ElifGroupList{
			ElifGroup:  $1.(*ElifGroup),
		}
	}
|	ElifGroupList ElifGroup
	{
		$$ = &ElifGroupList{
			Case:           1,
			ElifGroupList:  $1.(*ElifGroupList),
			ElifGroup:      $2.(*ElifGroup),
		}
	}

ElifGroupListOpt:
	/* empty */
	{
		$$ = (*ElifGroupListOpt)(nil)
		}
|	ElifGroupList
	{
		$$ = &ElifGroupListOpt{
			ElifGroupList:  $1.(*ElifGroupList).reverse(),
		}
	}

ElifGroup:
	PPELIF PPTokenList '\n' GroupListOpt
	{
		$$ = &ElifGroup{
			Token:         $1,
			PPTokenList:   $2,
			Token2:        $3,
			GroupListOpt:  $4.(*GroupListOpt),
		}
	}

ElseGroup:
	PPELSE '\n' GroupListOpt
	{
		$$ = &ElseGroup{
			Token:         $1,
			Token2:        $2,
			GroupListOpt:  $3.(*GroupListOpt),
		}
	}

ElseGroupOpt:
	/* empty */
	{
		$$ = (*ElseGroupOpt)(nil)
		}
|	ElseGroup
	{
		$$ = &ElseGroupOpt{
			ElseGroup:  $1.(*ElseGroup),
		}
	}

EndifLine:
	PPENDIF
	{
		$$ = &EndifLine{
			Token:  $1,
		}
	}

ControlLine:
	PPDEFINE IDENTIFIER ReplacementList
	{
		$$ = &ControlLine{
			Token:            $1,
			Token2:           $2,
			ReplacementList:  $3,
		}
	}
|	PPDEFINE IDENTIFIER_LPAREN "..." ')' ReplacementList
	{
		$$ = &ControlLine{
			Case:             1,
			Token:            $1,
			Token2:           $2,
			Token3:           $3,
			Token4:           $4,
			ReplacementList:  $5,
		}
	}
|	PPDEFINE IDENTIFIER_LPAREN IdentifierList ',' "..." ')' ReplacementList
	{
		$$ = &ControlLine{
			Case:             2,
			Token:            $1,
			Token2:           $2,
			IdentifierList:   $3.(*IdentifierList).reverse(),
			Token3:           $4,
			Token4:           $5,
			Token5:           $6,
			ReplacementList:  $7,
		}
	}
|	PPDEFINE IDENTIFIER_LPAREN IdentifierListOpt ')' ReplacementList
	{
		$$ = &ControlLine{
			Case:               3,
			Token:              $1,
			Token2:             $2,
			IdentifierListOpt:  $3.(*IdentifierListOpt),
			Token3:             $4,
			ReplacementList:    $5,
		}
	}
|	PPERROR PPTokenListOpt
	{
		$$ = &ControlLine{
			Case:            4,
			Token:           $1,
			PPTokenListOpt:  $2,
		}
	}
|	PPHASH_NL
	{
		$$ = &ControlLine{
			Case:   5,
			Token:  $1,
		}
	}
|	PPINCLUDE PPTokenList '\n'
	{
		$$ = &ControlLine{
			Case:         6,
			Token:        $1,
			PPTokenList:  $2,
			Token2:       $3,
		}
	}
|	PPLINE PPTokenList '\n'
	{
		$$ = &ControlLine{
			Case:         7,
			Token:        $1,
			PPTokenList:  $2,
			Token2:       $3,
		}
	}
|	PPPRAGMA PPTokenListOpt
	{
		$$ = &ControlLine{
			Case:            8,
			Token:           $1,
			PPTokenListOpt:  $2,
		}
	}
|	PPUNDEF IDENTIFIER '\n'
	{
		$$ = &ControlLine{
			Case:    9,
			Token:   $1,
			Token2:  $2,
			Token3:  $3,
		}
	}
|	PPDEFINE IDENTIFIER_LPAREN IDENTIFIER "..." ')' ReplacementList
	{
		lx := yylex.(*lexer)
		lhs := &ControlLine{
			Case:             10,
			Token:            $1,
			Token2:           $2,
			Token3:           $3,
			Token4:           $4,
			Token5:           $5,
			ReplacementList:  $6,
		}
		$$ = lhs
		if !lx.tweaks.enableDefineOmitCommaBeforeDDD {
			lx.report.ErrTok(lhs.Token4, "missing comma before \"...\"")
		}
	}
|	PPDEFINE IDENTIFIER_LPAREN IdentifierList ',' IDENTIFIER "..." ')' ReplacementList
	{
		lx := yylex.(*lexer)
		lhs := &ControlLine{
			Case:             11,
			Token:            $1,
			Token2:           $2,
			IdentifierList:   $3.(*IdentifierList).reverse(),
			Token3:           $4,
			Token4:           $5,
			Token5:           $6,
			Token6:           $7,
			ReplacementList:  $8,
		}
		$$ = lhs
		if !lx.tweaks.enableDefineOmitCommaBeforeDDD {
			lx.report.ErrTok(lhs.Token6, "missing comma before \"...\"")
		}
	}
|	PPDEFINE '\n'
	{
		lx := yylex.(*lexer)
		lhs := &ControlLine{
			Case:    12,
			Token:   $1,
			Token2:  $2,
		}
		$$ = lhs
		if !lx.tweaks.enableEmptyDefine {
			lx.report.ErrTok(lhs.Token2, "expected identifier")
		}
	}
|	PPUNDEF IDENTIFIER PPTokenList '\n'
	{
		lx := yylex.(*lexer)
		lhs := &ControlLine{
			Case:         13,
			Token:        $1,
			Token2:       $2,
			PPTokenList:  $3,
			Token3:       $4,
		}
		$$ = lhs
		if !lx.tweaks.enableUndefExtraTokens {
			lx.report.ErrTok(decodeTokens(lhs.PPTokenList, nil)[0], "extra tokens after #undef argument")
		}
	}

TextLine:
	PPTokenListOpt
	{
	}

ReplacementList:
	PPTokenListOpt
	{
	}

PPTokenList:
	PPTokens
	{
		lx := yylex.(*lexer)
		$$ = PPTokenList(dict.ID(lx.encBuf))
		lx.encBuf = lx.encBuf[:0]
		lx.encPos = 0
	}

PPTokenListOpt:
	'\n'
	{
		$$ = 0
	}
|	PPTokenList '\n'
	{
	}

PPTokens:
	PPOTHER
	{
	}
|	PPTokens PPOTHER
	{
	}
